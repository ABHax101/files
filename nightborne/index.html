<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nightborne Card Drawer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #eee;
            padding: 20px;
            min-height: 100vh;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            margin-bottom: 30px;
            color: #f39c12;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .controls {
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
        }

        .control-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            color: #f39c12;
            font-weight: bold;
        }

        select, button {
            width: 100%;
            padding: 10px;
            border-radius: 5px;
            border: 2px solid #f39c12;
            background: rgba(255,255,255,0.9);
            font-size: 16px;
            cursor: pointer;
        }

        button {
            background: #f39c12;
            color: white;
            font-weight: bold;
            margin-top: 10px;
            transition: all 0.3s;
        }

        button:hover {
            background: #e67e22;
            transform: translateY(-2px);
        }

        button:disabled {
            background: #666;
            cursor: not-allowed;
            border-color: #666;
        }

        .card-display {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            padding: 30px;
            border-radius: 15px;
            min-height: 300px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            border: 3px solid #f39c12;
        }

        .card-display.empty {
            display: flex;
            align-items: center;
            justify-content: center;
            color: #888;
            font-style: italic;
        }

        .card-header {
            border-bottom: 2px solid #f39c12;
            padding-bottom: 15px;
            margin-bottom: 20px;
        }

        .card-title {
            font-size: 28px;
            color: #f39c12;
            margin-bottom: 10px;
        }

        .card-subtitle {
            font-size: 16px;
            color: #bbb;
        }

        .card-content {
            line-height: 1.8;
        }

        .ability-item {
            background: rgba(255,255,255,0.05);
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 5px;
            border-left: 3px solid #f39c12;
        }

        .ability-name {
            font-weight: bold;
            color: #f39c12;
            margin-bottom: 5px;
        }

        .cooldown {
            display: inline-block;
            background: #e74c3c;
            color: white;
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 12px;
            margin-left: 10px;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-box {
            background: rgba(255,255,255,0.05);
            padding: 10px;
            border-radius: 5px;
            text-align: center;
            border: 2px solid #3498db;
        }

        .stat-label {
            font-size: 12px;
            color: #aaa;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 20px;
            font-weight: bold;
            color: #3498db;
        }

        .deck-info {
            margin-top: 15px;
            padding: 10px;
            background: rgba(52, 152, 219, 0.2);
            border-radius: 5px;
            font-size: 14px;
        }

        .options-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .warning {
            background: rgba(231, 76, 60, 0.2);
            border: 2px solid #e74c3c;
            padding: 15px;
            border-radius: 5px;
            margin-top: 15px;
        }

        .warning-title {
            font-weight: bold;
            color: #e74c3c;
            margin-bottom: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üé¥ Nightborne Card Drawer</h1>
        
        <div class="controls">
            <div class="control-group">
                <label for="deckType">Select Deck Type:</label>
                <select id="deckType">
                    <option value="">-- Choose a deck --</option>
                    <option value="creature">Creature Cards</option>
                    <option value="ability">Resonator Ability Cards</option>
                    <option value="catalyst">Catalyst Cards</option>
                    <option value="augment">Augment Cards</option>
                </select>
            </div>

            <div id="optionsContainer"></div>

            <button id="drawButton" disabled>Draw Card</button>
            <button id="reshuffleButton" style="background: #3498db; margin-top: 5px;">Reshuffle Deck</button>
        </div>

        <div class="card-display empty" id="cardDisplay">
            Select a deck type and draw a card to begin
        </div>

        <div id="drawnCardsList" style="margin-top: 20px;"></div>
    </div>

    <script>
        // ========================================
        // PASTE YOUR gameData OBJECT HERE
        // ========================================
        const gameData = {
            // Your creatures, abilities, catalysts, and augments data goes here
        };

        // Deck state management - stores state for each unique deck configuration
        let deckStates = {};
        let currentDeck = [];
        let drawnCards = [];
        let currentDeckKey = '';

        const deckTypeSelect = document.getElementById('deckType');
        const optionsContainer = document.getElementById('optionsContainer');
        const drawButton = document.getElementById('drawButton');
        const reshuffleButton = document.getElementById('reshuffleButton');
        const cardDisplay = document.getElementById('cardDisplay');
        const drawnCardsList = document.getElementById('drawnCardsList');

        deckTypeSelect.addEventListener('change', handleDeckTypeChange);
        drawButton.addEventListener('click', drawCard);
        reshuffleButton.addEventListener('click', reshuffleDeck);

        function getDeckKey() {
            const deckType = deckTypeSelect.value;
            if (!deckType) return '';
            
            if (deckType === 'creature') {
                const biome = document.getElementById('biomeSelect')?.value || '';
                const tier = document.getElementById('tierSelect')?.value || '';
                return `creature-${biome}-${tier}`;
            } else if (deckType === 'ability') {
                const resonator = document.getElementById('resonatorSelect')?.value || '';
                return `ability-${resonator}`;
            } else {
                return deckType;
            }
        }

        function saveDeckState() {
            if (currentDeckKey) {
                deckStates[currentDeckKey] = {
                    deck: [...currentDeck],
                    drawn: [...drawnCards]
                };
            }
        }

        function loadDeckState() {
            currentDeckKey = getDeckKey();
            if (deckStates[currentDeckKey]) {
                currentDeck = [...deckStates[currentDeckKey].deck];
                drawnCards = [...deckStates[currentDeckKey].drawn];
            } else {
                currentDeck = [];
                drawnCards = [];
            }
        }

        function updateDrawnCardsList() {
            if (drawnCards.length === 0) {
                drawnCardsList.innerHTML = '';
                return;
            }

            const deckType = deckTypeSelect.value;
            let listHTML = `
                <div style="background: rgba(255,255,255,0.1); padding: 20px; border-radius: 10px; backdrop-filter: blur(10px);">
                    <h3 style="color: #f39c12; margin-bottom: 15px;">üìú Previously Drawn Cards</h3>
                    <div style="display: flex; flex-direction: column; gap: 10px;">
            `;

            // Show most recent first (reverse order)
            for (let i = drawnCards.length - 1; i >= 0; i--) {
                const card = drawnCards[i];
                let cardSummary = '';

                if (deckType === 'creature') {
                    cardSummary = `<strong>${card.name}</strong> <span style="color: #aaa;">(${card.biome}, Tier ${card.tier}, ${card.corruption} Corruption)</span>`;
                } else if (deckType === 'ability') {
                    cardSummary = `<strong>${card.name}</strong> <span style="color: #aaa;">(${card.cooldown} turn cooldown)</span>`;
                } else {
                    cardSummary = `<strong>${card.name}</strong>`;
                }

                listHTML += `
                    <div style="background: rgba(255,255,255,0.05); padding: 10px; border-radius: 5px; border-left: 3px solid #3498db;">
                        ${cardSummary}
                    </div>
                `;
            }

            listHTML += `
                    </div>
                </div>
            `;

            drawnCardsList.innerHTML = listHTML;
        }

        function handleDeckTypeChange() {
            saveDeckState(); // Save current state before switching
            
            const deckType = deckTypeSelect.value;
            optionsContainer.innerHTML = '';
            cardDisplay.className = 'card-display empty';
            cardDisplay.innerHTML = 'Select options and draw a card';

            if (!deckType) {
                drawButton.disabled = true;
                currentDeckKey = '';
                currentDeck = [];
                drawnCards = [];
                updateDrawnCardsList();
                return;
            }

            if (deckType === 'creature') {
                optionsContainer.innerHTML = `
                    <div class="options-grid">
                        <div class="control-group">
                            <label for="biomeSelect">Biome:</label>
                            <select id="biomeSelect">
                                <option value="all">All Biomes (Mixed)</option>
                                <option value="Verdant Hollow">Verdant Hollow</option>
                                <option value="Frostbound Expanse">Frostbound Expanse</option>
                                <option value="Ashen Wastes">Ashen Wastes</option>
                                <option value="Ethereal Canopy">Ethereal Canopy</option>
                                <option value="Crimson Mire">Crimson Mire</option>
                            </select>
                        </div>
                        <div class="control-group">
                            <label for="tierSelect">Corruption Node:</label>
                            <select id="tierSelect">
                                <option value="normal">Normal (Tier 1)</option>
                                <option value="major">Major (Tier 2 & 3)</option>
                            </select>
                        </div>
                    </div>
                `;
                document.getElementById('biomeSelect').addEventListener('change', () => {
                    saveDeckState();
                    buildCreatureDeck();
                });
                document.getElementById('tierSelect').addEventListener('change', () => {
                    saveDeckState();
                    buildCreatureDeck();
                });
                buildCreatureDeck();
            } else if (deckType === 'ability') {
                optionsContainer.innerHTML = `
                    <div class="control-group">
                        <label for="resonatorSelect">Resonator Class:</label>
                        <select id="resonatorSelect">
                            <option value="Grove Harmonizer">Grove Harmonizer</option>
                            <option value="Astral Tuner">Astral Tuner</option>
                            <option value="Frost Calibrator">Frost Calibrator</option>
                            <option value="Shadow Weaver">Shadow Weaver</option>
                        </select>
                    </div>
                    <div class="deck-info">
                        Draw 4 ability cards at setup. Choose 3 to keep, shuffle the rest back.
                    </div>
                `;
                document.getElementById('resonatorSelect').addEventListener('change', () => {
                    saveDeckState();
                    buildAbilityDeck();
                });
                buildAbilityDeck();
            } else if (deckType === 'catalyst') {
                buildCatalystDeck();
                drawButton.disabled = false;
            } else if (deckType === 'augment') {
                buildAugmentDeck();
                drawButton.disabled = false;
            }
        }

        function buildCreatureDeck() {
            const biome = document.getElementById('biomeSelect').value;
            const tier = document.getElementById('tierSelect').value;
            
            loadDeckState();
            
            // Only rebuild if this is a new deck configuration
            if (currentDeck.length === 0 && drawnCards.length === 0) {
                const biomes = biome === 'all' ? Object.keys(gameData.creatures) : [biome];

                biomes.forEach(biomeName => {
                    const biomeData = gameData.creatures[biomeName];
                    
                    if (tier === 'normal') {
                        // Tier 1: 5 copies each
                        biomeData.tier1.forEach(creature => {
                            for (let i = 0; i < 5; i++) {
                                currentDeck.push({ ...creature, biome: biomeName, tier: 1 });
                            }
                        });
                    } else {
                        // Tier 2: 4 copies each
                        biomeData.tier2.forEach(creature => {
                            for (let i = 0; i < 4; i++) {
                                currentDeck.push({ ...creature, biome: biomeName, tier: 2 });
                            }
                        });
                        // Tier 3: 2 copies each
                        biomeData.tier3.forEach(creature => {
                            for (let i = 0; i < 2; i++) {
                                currentDeck.push({ ...creature, biome: biomeName, tier: 3 });
                            }
                        });
                    }
                });

                shuffleDeck(currentDeck);
            }
            
            saveDeckState();
            drawButton.disabled = false;
            updateDrawnCardsList();
        }

        function buildAbilityDeck() {
            const resonator = document.getElementById('resonatorSelect').value;
            
            loadDeckState();
            
            if (currentDeck.length === 0 && drawnCards.length === 0) {
                currentDeck = gameData.abilities[resonator].map(a => ({ ...a, resonator }));
                shuffleDeck(currentDeck);
            }
            
            saveDeckState();
            drawButton.disabled = false;
            updateDrawnCardsList();
        }

        function buildCatalystDeck() {
            loadDeckState();
            
            if (currentDeck.length === 0 && drawnCards.length === 0) {
                gameData.catalysts.forEach(catalyst => {
                    for (let i = 0; i < catalyst.count; i++) {
                        currentDeck.push({ ...catalyst });
                    }
                });
                shuffleDeck(currentDeck);
            }
            
            saveDeckState();
            updateDrawnCardsList();
        }

        function buildAugmentDeck() {
            loadDeckState();
            
            if (currentDeck.length === 0 && drawnCards.length === 0) {
                gameData.augments.forEach(augment => {
                    for (let i = 0; i < augment.count; i++) {
                        currentDeck.push({ ...augment });
                    }
                });
                shuffleDeck(currentDeck);
            }
            
            saveDeckState();
            updateDrawnCardsList();
        }

        function shuffleDeck(deck) {
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
        }

        function reshuffleDeck() {
            // Clear the state for this deck configuration
            currentDeckKey = getDeckKey();
            if (currentDeckKey) {
                delete deckStates[currentDeckKey];
            }
            
            drawnCards = [];
            const deckType = deckTypeSelect.value;
            
            if (deckType === 'creature') {
                buildCreatureDeck();
            } else if (deckType === 'ability') {
                buildAbilityDeck();
            } else if (deckType === 'catalyst') {
                buildCatalystDeck();
            } else if (deckType === 'augment') {
                buildAugmentDeck();
            }
            
            cardDisplay.className = 'card-display empty';
            cardDisplay.innerHTML = 'Deck reshuffled! Draw a card to continue.';
            updateDrawnCardsList();
        }

        function drawCard() {
            if (currentDeck.length === 0) {
                cardDisplay.className = 'card-display empty';
                cardDisplay.innerHTML = 'No cards left in deck! Click "Reshuffle Deck" to continue.';
                return;
            }

            // Get a random card from the deck
            const randomIndex = Math.floor(Math.random() * currentDeck.length);
            const card = currentDeck.splice(randomIndex, 1)[0];
            drawnCards.push(card);

            saveDeckState();
            displayCard(card);
            updateDrawnCardsList();
        }

        function displayCard(card) {
            cardDisplay.className = 'card-display';
            const deckType = deckTypeSelect.value;

            if (deckType === 'creature') {
                cardDisplay.innerHTML = `
                    <div class="card-header">
                        <div class="card-title">${card.name}</div>
                        <div class="card-subtitle">${card.biome} ‚Ä¢ Tier ${card.tier}</div>
                    </div>
                    <div class="stats">
                        <div class="stat-box">
                            <div class="stat-label">Base Corruption</div>
                            <div class="stat-value">${card.corruption}</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-label">Flux Type</div>
                            <div class="stat-value">${card.fluxType}</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-label">Weakness</div>
                            <div class="stat-value">${card.weakness}</div>
                        </div>
                    </div>
                    <div class="card-content">
                        <strong style="color: #f39c12;">Abilities:</strong>
                        ${card.abilities.map(ability => `
                            <div class="ability-item">${ability}</div>
                        `).join('')}
                    </div>
                    <div class="deck-info">
                        Cards remaining: ${currentDeck.length} | Cards drawn: ${drawnCards.length}
                    </div>
                `;
            } else if (deckType === 'ability') {
                cardDisplay.innerHTML = `
                    <div class="card-header">
                        <div class="card-title">${card.name}</div>
                        <div class="card-subtitle">${card.resonator}</div>
                    </div>
                    <div class="stats">
                        <div class="stat-box">
                            <div class="stat-label">Cooldown</div>
                            <div class="stat-value">${card.cooldown} Turn${card.cooldown !== 1 ? 's' : ''}</div>
                        </div>
                    </div>
                    <div class="card-content">
                        <div class="ability-item">
                            <div style="font-size: 18px; color: #fff; margin-bottom: 10px;">${card.effect}</div>
                        </div>
                    </div>
                    <div class="deck-info">
                        Cards remaining: ${currentDeck.length} | Cards drawn: ${drawnCards.length}
                    </div>
                `;
            } else if (deckType === 'catalyst') {
                const isSecret = card.name === 'Corrupt Influence';
                cardDisplay.innerHTML = `
                    <div class="card-header">
                        <div class="card-title">${card.name}</div>
                        <div class="card-subtitle">Catalyst Card</div>
                    </div>
                    <div class="card-content">
                        <div class="ability-item">
                            ${card.effect}
                        </div>
                    </div>
                    ${isSecret ? '<div class="warning"><div class="warning-title">‚ö†Ô∏è SECRET CARD</div>Keep this card hidden from other players!</div>' : ''}
                    <div class="deck-info">
                        Cards remaining: ${currentDeck.length} | Cards drawn: ${drawnCards.length}
                    </div>
                `;
            } else if (deckType === 'augment') {
                cardDisplay.innerHTML = `
                    <div class="card-header">
                        <div class="card-title">${card.name}</div>
                        <div class="card-subtitle">Augment Card</div>
                    </div>
                    <div class="card-content">
                        <div class="ability-item">
                            ${card.effect}
                        </div>
                    </div>
                    <div class="deck-info">
                        Cards remaining: ${currentDeck.length} | Cards drawn: ${drawnCards.length}
                    </div>
                `;
            }
        }
    </script>
</body>
</html>